# 示例教程

<cite>
**本文档中引用的文件**
- [Cargo.toml](file://Cargo.toml)
- [README.md](file://README.md)
- [src/lib.rs](file://src/lib.rs)
- [src/models/gaussian.rs](file://src/models/gaussian.rs)
- [src/models/beta.rs](file://src/models/beta.rs)
- [src/base/types.rs](file://src/base/types.rs)
- [src/algorithms/forward.rs](file://src/algorithms/forward.rs)
- [src/algorithms/viterbi.rs](file://src/algorithms/viterbi.rs)
- [src/algorithms/baum_welch.rs](file://src/algorithms/baum_welch.rs)
- [src/utils/validation.rs](file://src/utils/validation.rs)
- [src/utils/mod.rs](file://src/utils/mod.rs)
- [examples/beta_hmm_example.rs](file://examples/beta_hmm_example.rs)
- [tests/integration_tests.rs](file://tests/integration_tests.rs)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概览](#架构概览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)
10. [附录](#附录)

## 简介

rhmm 是一个用 Rust 实现的隐马尔可夫模型（Hidden Markov Model）库，灵感来源于 Python 的 hmmlearn。该库提供了高效的 HMM 模型实现，支持多种发射分布类型和标准的 HMM 算法。项目采用 ndarray 进行数值计算，提供了从基础到高级的完整使用示例。

主要特性包括：
- 多种 HMM 模型类型：高斯 HMM、Beta HMM、多项式 HMM（即将推出）、高斯混合 HMM（即将推出）
- 标准 HMM 算法：前向算法、后向算法、维特比算法、Baum-Welch 算法
- 高效实现：基于 ndarray 的快速数值运算
- 支持多种协方差类型：对角、球面、完整、绑定
- 健壮的数值稳定性：使用对数空间计算

## 项目结构

```mermaid
graph TB
subgraph "根目录"
Cargo[Cargo.toml]
README[README.md]
Examples[examples/]
Tests[tests/]
end
subgraph "src/"
Lib[src/lib.rs]
subgraph "algorithms/"
Forward[src/algorithms/forward.rs]
Viterbi[src/algorithms/viterbi.rs]
BaumWelch[src/algorithms/baum_welch.rs]
Mod1[src/algorithms/mod.rs]
end
subgraph "base/"
Types[src/base/types.rs]
HMM[src/base/hmm.rs]
Mod2[src/base/mod.rs]
end
subgraph "models/"
Gaussian[src/models/gaussian.rs]
Beta[src/models/beta.rs]
Multinomial[src/models/multinomial.rs]
GMM[src/models/gmm.rs]
Mod3[src/models/mod.rs]
end
subgraph "utils/"
Validation[src/utils/validation.rs]
Normalization[src/utils/normalization.rs]
Sampling[src/utils/sampling.rs]
Sequences[src/utils/sequences.rs]
Mod4[src/utils/mod.rs]
end
Errors[src/errors.rs]
end
Examples --> Lib
Tests --> Lib
Lib --> Algorithms
Lib --> Base
Lib --> Models
Lib --> Utils
```

**图表来源**
- [src/lib.rs](file://src/lib.rs#L1-L28)
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L1-L681)
- [src/models/beta.rs](file://src/models/beta.rs#L1-L734)

**章节来源**
- [Cargo.toml](file://Cargo.toml#L1-L23)
- [src/lib.rs](file://src/lib.rs#L1-L28)

## 核心组件

### 隐藏马尔可夫模型核心接口

所有 HMM 模型都实现了统一的 `HiddenMarkovModel` trait，提供一致的 API 接口：

```mermaid
classDiagram
class HiddenMarkovModel {
<<trait>>
+n_states() usize
+n_features() usize
+fit(observations, lengths) Result
+predict(observations) Result~Array1~usize~~
+score(observations) Result~f64~
+sample(n_samples) Result~(Array2~f64~, Array1~usize)~
+decode(observations) Result~(f64, Array1~usize)~
}
class GaussianHMM {
-n_states : usize
-n_features : usize
-covariance_type : CovarianceType
-start_prob : Option~Array1~f64~~
-transition_matrix : Option~Array2~f64~~
-means : Option~Array2~f64~~
-covars : Option~Array2~f64~~
-is_fitted : bool
+new(n_states) GaussianHMM
+with_covariance_type(n_states, covariance_type) GaussianHMM
+covariance_type() CovarianceType
+means() Option~&Array2~f64~~
+covars() Option~&Array2~f64~~
+transition_matrix() Option~&Array2~f64~~
+start_prob() Option~&Array1~f64~~
+is_fitted() bool
}
class BetaHMM {
-n_states : usize
-n_features : usize
-start_prob : Option~Array1~f64~~
-transition_matrix : Option~Array2~f64~~
-alphas : Option~Array2~f64~~
-betas : Option~Array2~f64~~
-is_fitted : bool
+new(n_states) BetaHMM
+alphas() Option~&Array2~f64~~
+betas() Option~&Array2~f64~~
+transition_matrix() Option~&Array2~f64~~
+start_prob() Option~&Array1~f64~~
+is_fitted() bool
+compute_means() Option~Array2~f64~~
+compute_variances() Option~Array2~f64~~
}
HiddenMarkovModel <|-- GaussianHMM
HiddenMarkovModel <|-- BetaHMM
```

**图表来源**
- [src/base/types.rs](file://src/base/types.rs#L1-L61)
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L11-L32)
- [src/models/beta.rs](file://src/models/beta.rs#L24-L39)

### 协方差类型枚举

高斯 HMM 支持多种协方差类型，每种类型都有不同的数学特性和计算复杂度：

```mermaid
classDiagram
class CovarianceType {
<<enumeration>>
+Full
+Diagonal
+Spherical
+Tied
}
note for CovarianceType "默认值 : Diagonal\n\nFull : 完整协方差矩阵\nDiagonal : 对角协方差矩阵\nSpherical : 球面协方差单个方差值\nTied : 绑定协方差所有状态相同"
```

**图表来源**
- [src/base/types.rs](file://src/base/types.rs#L17-L29)

**章节来源**
- [src/base/types.rs](file://src/base/types.rs#L1-L61)
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L14-L32)

## 架构概览

### 算法模块架构

```mermaid
graph TB
subgraph "算法层"
Forward[前向算法<br/>forward_algorithm]
Backward[后向算法<br/>backward_algorithm]
Viterbi[维特比算法<br/>viterbi_algorithm]
BaumWelch[Baum-Welch算法<br/>baum_welch]
Gamma[Gamma计算<br/>compute_gamma]
end
subgraph "模型层"
Gaussian[高斯HMM]
Beta[BetaHMM]
Multinomial[多项式HMM]
GMM[GMM-HMM]
end
subgraph "工具层"
Validation[参数验证]
Normalization[向量归一化]
Sampling[采样函数]
Sequences[序列处理]
end
Forward --> Gaussian
Forward --> Beta
Backward --> Gaussian
Backward --> Beta
Viterbi --> Gaussian
Viterbi --> Beta
BaumWelch --> Gaussian
BaumWelch --> Beta
Validation --> Gaussian
Validation --> Beta
Normalization --> BaumWelch
Sampling --> Gaussian
Sampling --> Beta
```

**图表来源**
- [src/algorithms/mod.rs](file://src/algorithms/mod.rs#L1-L12)
- [src/utils/mod.rs](file://src/utils/mod.rs#L1-L12)

### 数据流架构

```mermaid
sequenceDiagram
participant User as 用户
participant Model as HMM模型
participant Algo as 算法模块
participant Utils as 工具模块
User->>Model : 创建模型(new/with_covariance_type)
User->>Model : 训练(fit)
Model->>Utils : 参数验证(validate_*)
Model->>Algo : 前向算法(forward)
Model->>Algo : 后向算法(backward)
Model->>Algo : Gamma计算(compute_gamma)
Model->>Algo : 维特比算法(viterbi)
Model->>Model : 更新参数(update_emission_parameters)
User->>Model : 预测(predict)
Model->>Algo : 前向算法(forward)
Model->>Algo : 维特比算法(viterbi)
User->>Model : 评分(score)
Model->>Algo : 前向算法(forward)
User->>Model : 采样(sample)
Model->>Utils : 分布采样(sampling)
```

**图表来源**
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L337-L491)
- [src/models/beta.rs](file://src/models/beta.rs#L393-L547)

## 详细组件分析

### 高斯 HMM 模型

#### 模型实现分析

高斯 HMM 使用高斯分布作为发射分布，适用于连续数据建模：

```mermaid
classDiagram
class GaussianHMM {
-n_states : usize
-n_features : usize
-covariance_type : CovarianceType
-start_prob : Option~Array1~f64~~
-transition_matrix : Option~Array2~f64~~
-means : Option~Array2~f64~~
-covars : Option~Array2~f64~~
-is_fitted : bool
+gaussian_pdf(x, mean, covar) Result~f64~
+initialize_parameters(observations) Result
+compute_emission_probs(observations) Result~Array2~f64~~
+update_emission_parameters(observations, gamma) Result
}
class CovarianceType {
<<enumeration>>
Full
Diagonal
Spherical
Tied
}
GaussianHMM --> CovarianceType : 使用
```

**图表来源**
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L14-L32)
- [src/base/types.rs](file://src/base/types.rs#L17-L29)

#### 高斯概率密度函数实现

高斯 HMM 实现了针对不同协方差类型的优化计算：

```mermaid
flowchart TD
Start([输入: 观测值x, 均值mean, 协方差covar]) --> CheckType{"检查协方差类型"}
CheckType --> |Diagonal| DiagCalc["对角协方差计算<br/>- 计算对数行列式<br/>- 计算马氏距离<br/>- 返回概率密度"]
CheckType --> |Spherical| SphCalc["球面协方差计算<br/>- 使用单一方差值<br/>- 计算标准化距离"]
CheckType --> |Full/Tied| FullCalc["完整/绑定协方差计算<br/>- 简化实现为对角版本<br/>- 需要矩阵运算"]
DiagCalc --> End([输出: 概率密度值])
SphCalc --> End
FullCalc --> End
```

**图表来源**
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L147-L194)

**章节来源**
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L1-L681)

### Beta HMM 模型

#### Beta 分布实现

Beta HMM 使用 Beta 分布作为发射分布，专门用于 [0,1] 区间的数据建模：

```mermaid
classDiagram
class BetaHMM {
-n_states : usize
-n_features : usize
-start_prob : Option~Array1~f64~~
-transition_matrix : Option~Array2~f64~~
-alphas : Option~Array2~f64~~
-betas : Option~Array2~f64~~
-is_fitted : bool
+beta_pdf(x, alpha, beta) Result~f64~
+moments_to_params(mean, var) (f64, f64)
+initialize_parameters(observations) Result
+compute_emission_probs(observations) Result~Array2~f64~~
+update_emission_parameters(observations, gamma) Result
+compute_means() Option~Array2~f64~~
+compute_variances() Option~Array2~f64~~
}
note for BetaHMM "Beta分布参数 : \n- α (alpha) : 形状参数1\n- β (beta) : 形状参数2\n\n均值 : α/(α+β)\n方差 : (αβ)/((α+β)²(α+β+1))"
```

**图表来源**
- [src/models/beta.rs](file://src/models/beta.rs#L24-L39)

#### Beta 分布概率密度函数

Beta HMM 实现了数值稳定的对数概率密度计算：

```mermaid
flowchart TD
Start([输入: 观测值x, α参数, β参数]) --> Validate["验证观测值在(0,1)范围内"]
Validate --> LoopFeatures["遍历每个特征"]
LoopFeatures --> Clamp["夹紧观测值到(1e-10, 1-1e-10)"]
Clamp --> CalcLogPDF["计算对数PDF:\nlog(Γ(α))/Γ(β))-Γ(α+β)) + (α-1)log(x) + (β-1)log(1-x)"]
CalcLogPDF --> SumLog["累加所有特征的对数PDF"]
SumLog --> Exp["取指数得到概率密度"]
Exp --> End([输出: 概率密度值])
```

**图表来源**
- [src/models/beta.rs](file://src/models/beta.rs#L173-L197)

**章节来源**
- [src/models/beta.rs](file://src/models/beta.rs#L1-L734)

### 核心算法实现

#### 前向算法

前向算法计算给定观测序列和模型参数下，部分观测序列和处于特定状态的概率：

```mermaid
sequenceDiagram
participant Input as 输入
participant Alpha as Alpha矩阵
participant Init as 初始化
Input->>Init : 设置初始概率
Init->>Alpha : alpha[0,i] = π[i] * b_i(O[0])
loop 时间步 t=1..T-1
Input->>Alpha : 计算alpha[t,j]
Alpha->>Alpha : alpha[t,j] = [Σ_i alpha[t-1,i] * a_ij] * b_j(O[t])
end
Note over Alpha : 最终概率 P(O|λ) ≈ Σ_i alpha[T-1,i]
```

**图表来源**
- [src/algorithms/forward.rs](file://src/algorithms/forward.rs#L20-L47)

#### 维特比算法

维特比算法找到最可能的状态序列：

```mermaid
flowchart TD
Start([初始化]) --> InitViterbi["设置viterbi[0,i] = log(π[i]) + log(b_i(O[0]))"]
InitViterbi --> ForwardPass["向前传递:<br/>viterbi[t,j] = max_i[viterbi[t-1,i] + log(a_ij)] + log(b_j(O[t]))"]
ForwardPass --> FindLastState["找到最终状态:<br/>last_state = argmax_i[viterbi[T-1,i]]"]
FindLastState --> Backtrack["向后回溯:<br/>path[t-1] = backpointer[t,path[t]]"]
Backtrack --> End([输出: 最可能路径])
```

**图表来源**
- [src/algorithms/viterbi.rs](file://src/algorithms/viterbi.rs#L20-L74)

**章节来源**
- [src/algorithms/forward.rs](file://src/algorithms/forward.rs#L1-L129)
- [src/algorithms/viterbi.rs](file://src/algorithms/viterbi.rs#L1-L118)

## 依赖关系分析

### 外部依赖关系

```mermaid
graph TB
subgraph "核心依赖"
ndarray[ndarray 0.17.2<br/>N维数组]
ndarray_linalg[ndarray-linalg 0.18.1<br/>线性代数]
rand[rand 0.9.2<br/>随机数生成]
rand_distr[rand_distr 0.5.1<br/>概率分布]
thiserror[thiserror 2.0.18<br/>错误处理]
serde[serde 1.0<br/>序列化支持]
end
subgraph "开发依赖"
approx[approx 0.5<br/>近似比较]
end
rhmm[rhmm库] --> ndarray
rhmm --> ndarray_linalg
rhmm --> rand
rhmm --> rand_distr
rhmm --> thiserror
rhmm --> serde
```

**图表来源**
- [Cargo.toml](file://Cargo.toml#L13-L22)

### 内部模块依赖

```mermaid
graph TB
subgraph "核心模块"
lib[lib.rs]
base[base模块]
models[models模块]
algorithms[algorithms模块]
utils[utils模块]
errors[errors模块]
end
subgraph "具体实现"
gaussian[gaussian.rs]
beta[beta.rs]
multinomial[multinomial.rs]
gmm[gmm.rs]
forward[forward.rs]
viterbi[viterbi.rs]
baum_welch[baum_welch.rs]
validation[validation.rs]
normalization[normalization.rs]
sampling[sampling.rs]
sequences[sequences.rs]
end
lib --> base
lib --> models
lib --> algorithms
lib --> utils
lib --> errors
models --> gaussian
models --> beta
models --> multinomial
models --> gmm
algorithms --> forward
algorithms --> viterbi
algorithms --> baum_welch
utils --> validation
utils --> normalization
utils --> sampling
utils --> sequences
gaussian --> algorithms
gaussian --> utils
gaussian --> base
beta --> algorithms
beta --> utils
beta --> base
```

**图表来源**
- [src/lib.rs](file://src/lib.rs#L19-L28)
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L3-L9)
- [src/models/beta.rs](file://src/models/beta.rs#L3-L9)

**章节来源**
- [Cargo.toml](file://Cargo.toml#L1-L23)
- [src/lib.rs](file://src/lib.rs#L1-L28)

## 性能考虑

### 数值稳定性优化

1. **对数空间计算**: 所有概率计算都在对数空间进行，避免数值下溢
2. **稳定归一化**: 使用稳定的向量归一化函数
3. **参数约束**: 强制要求概率参数在有效范围内

### 内存管理

1. **最小分配**: 在热路径上尽量减少内存分配
2. **就地操作**: 尽可能使用就地修改操作
3. **向量化**: 利用 ndarray 的向量化操作

### 并行化机会

虽然当前实现是串行的，但以下部分可以考虑并行化：
- 多序列训练时的序列独立处理
- 特征维度上的并行计算
- 大规模观测矩阵的批处理

## 故障排除指南

### 常见错误类型

```mermaid
classDiagram
class HmmError {
<<enumeration>>
+InvalidParameter(string)
+InvalidProbability(string)
+DimensionMismatch(DimensionMismatch)
+ModelNotFitted(string)
+NumericalError(string)
}
class DimensionMismatch {
+expected : usize
+actual : usize
}
HmmError --> DimensionMismatch : 包含
```

**图表来源**
- [src/errors.rs](file://src/errors.rs#L1-L100)

### 错误处理最佳实践

1. **参数验证**: 在训练前验证所有输入参数
2. **状态检查**: 确保模型已训练后再进行预测或评分
3. **维度匹配**: 验证观测数据的维度与模型配置一致

**章节来源**
- [src/utils/validation.rs](file://src/utils/validation.rs#L1-L141)
- [src/models/gaussian.rs](file://src/models/gaussian.rs#L494-L505)
- [src/models/beta.rs](file://src/models/beta.rs#L550-L561)

## 结论

rhmm 库提供了完整的 HMM 实现，具有以下优势：

1. **一致性**: 统一的 API 设计，便于在不同模型间切换
2. **数值稳定性**: 基于对数空间的计算，确保数值精度
3. **扩展性**: 模块化的架构设计，易于添加新的模型类型
4. **性能**: 基于 ndarray 的高效实现

未来发展方向包括：
- 添加更多发射分布类型
- 实现并行训练
- 改进文档和示例
- 考虑 GPU 加速支持

## 附录

### 快速开始示例

#### 高斯 HMM 基础使用

```rust
use ndarray::array;
use rhmm::models::GaussianHMM;
use rhmm::base::HiddenMarkovModel;

fn main() {
    // 创建训练数据
    let observations = array![
        [0.5, 1.0],
        [0.6, 1.1],
        [5.0, 6.0],
        [5.1, 6.2],
    ];

    // 创建并训练模型
    let mut model = GaussianHMM::new(2);
    model.fit(&observations, None).unwrap();

    // 预测隐藏状态
    let states = model.predict(&observations).unwrap();
    println!("预测状态: {:?}", states);

    // 计算对数似然
    let log_prob = model.score(&observations).unwrap();
    println!("对数概率: {:.4}", log_prob);

    // 生成合成数据
    let (sampled_obs, sampled_states) = model.sample(10).unwrap();
    println!("生成了 {} 个样本", sampled_obs.nrows());
}
```

#### Beta HMM 比例数据分析

```rust
use ndarray::array;
use rhmm::models::BetaHMM;
use rhmm::base::HiddenMarkovModel;

fn main() {
    // 转换率数据（值在0到1之间）
    let observations = array![
        [0.12, 0.15],  // 低转换
        [0.10, 0.13],  // 低转换
        [0.75, 0.82],  // 高转换
        [0.78, 0.85],  // 高转换
    ];

    // 创建并训练模型
    let mut model = BetaHMM::new(2);
    model.fit(&observations, None).unwrap();

    // 预测状态
    let states = model.predict(&observations).unwrap();
    println!("状态: {:?}", states);

    // 获取学习到的参数
    if let (Some(alphas), Some(betas)) = (model.alphas(), model.betas()) {
        println!("Alpha参数: {:?}", alphas);
        println!("Beta参数: {:?}", betas);
    }
}
```

### 高级用法示例

#### 多序列训练

```rust
let observations = array![/* 连接的序列 */];
let lengths = vec![10, 15, 20]; // 每个序列的长度
model.fit(&observations, Some(&lengths)).unwrap();
```

#### 自定义初始化

```rust
let mut model = GaussianHMM::new(3);
// 在拟合前设置自定义初始参数
// model.set_start_prob(...);
// model.set_transition_matrix(...);
model.fit(&observations, None).unwrap();
```

#### 协方差类型选择

```rust
use rhmm::base::CovarianceType;

// 对角协方差（默认）
let model = GaussianHMM::with_covariance_type(3, CovarianceType::Diagonal);

// 球面协方差（单个方差）
let model = GaussianHMM::with_covariance_type(3, CovarianceType::Spherical);

// 完整协方差矩阵
let model = GaussianHMM::with_covariance_type(3, CovarianceType::Full);
```

### 测试和验证

```rust
// 运行测试套件
cargo test

// 运行特定测试
cargo test integration_tests

// 查看测试输出
cargo test -- --nocapture
```

**章节来源**
- [README.md](file://README.md#L53-L119)
- [README.md](file://README.md#L230-L266)
- [tests/integration_tests.rs](file://tests/integration_tests.rs#L1-L103)